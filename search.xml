<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vscode中开启emmet对jsx的支持]]></title>
    <url>%2F2018%2F03%2F03%2Fvscode%E4%B8%AD%E5%BC%80%E5%90%AFemmet%E5%AF%B9jsx%E7%9A%84%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[在用户配置文件里添加如下配置, class会自动转化为className 1234"emmet.syntaxProfiles": &#123; "javascript": "jsx" &#125;,"emmet.triggerExpansionOnTab": true,]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-mobx-less-router架构起手]]></title>
    <url>%2F2018%2F03%2F02%2Freact-mobx-less-router%E6%9E%B6%E6%9E%84%E8%B5%B7%E6%89%8B%2F</url>
    <content type="text"><![CDATA[使用create-react-app创建项目创建项目create-react-app project 抛出配置文件npm run eject mobx安装mobxnpm install mobx mobx-react –save mobx中文文档 启用装饰器语法 在MobX 中使用 ES.next 装饰器是可选的。本章节将解释如何(避免)使用它们。 使用装饰器的优势: 样板文件最小化，声明式代码。易于使用和阅读。大多数 MobX 用户都在使用。 Babel中启用装饰器安装依赖npm i –save-dev babel-plugin-transform-decorators-legacy 编辑package.json，添加plugins，修改后如下 12345678"babel": &#123; "presets": [ "react-app" ], "plugins": [ "transform-decorators-legacy" ] &#125;, 在index.js文件中注入store1234567891011121314151617181920import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import registerServiceWorker from './registerServiceWorker';import &#123; HashRouter &#125; from 'react-router-dom';import &#123; Provider &#125; from 'mobx-react';import ResumeStore from './store/ResumeStore';let stores = &#123; ResumeStore,&#125;;ReactDOM.render(( &lt;Provider &#123;...stores&#125;&gt; &lt;HashRouter&gt; &lt;App /&gt; &lt;/HashRouter&gt; &lt;/Provider&gt;),document.getElementById('root'));registerServiceWorker(); 配置react-router安装react-routernpm install –save react-router App.js文件中配置路由123456789101112131415161718192021import React, &#123; Component &#125; from 'react';import './App.less';import &#123; Route, Switch,&#125; from 'react-router-dom'import Index from './page/Index';class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Switch&gt; &lt;Route path="/" component=&#123;Index&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; ); &#125;&#125;export default App; 配置 less安装依赖npm install less-loader less –save-dev 修改配置文件修改 config文件夹下的 webpack.config.dev.js 和 webpack.config-prod.js test: /.css$/ 改为 /.(css|less)$/ test: /.css$/ 的 use 数组配置增加 less-loader 修改后 1234567891011121314151617181920212223242526272829303132333435&#123; test: /\.(css|less)$/, use: [ require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('less-loader') // compiles Less to CSS &#125; ],&#125;]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【翻译】没有常春藤学校学位的我是如何获得微软、亚马逊、推特的offer]]></title>
    <url>%2F2018%2F03%2F02%2F%E7%BF%BB%E8%AF%91-%E6%B2%A1%E6%9C%89%E5%B8%B8%E6%98%A5%E8%97%A4%E5%AD%A6%E6%A0%A1%E5%AD%A6%E4%BD%8D%E7%9A%84%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E5%BE%AE%E8%BD%AF%E3%80%81%E4%BA%9A%E9%A9%AC%E9%80%8A%E3%80%81%E6%8E%A8%E7%89%B9%E7%9A%84offer%2F</url>
    <content type="text"><![CDATA[原文：How I landed offers from Microsoft, Amazon, and Twitter without an Ivy League degree]]></content>
      <tags>
        <tag>job</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript有用的代码片段]]></title>
    <url>%2F2018%2F02%2F20%2FJavaScript%E6%9C%89%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8Ctrick%2F</url>
    <content type="text"><![CDATA[参考 JavaScript有用的代码片段和trick 浮点数取整12345const x = 123.4545;x &gt;&gt; 0; // 123~~x; // 123x | 0; // 123Math.floor(x); // 123 注意：前三种方法只适用于32个位整数，对于负数的处理上和Math.floor是不同的。123&gt; Math.floor(-12.53); // -13&gt; -12.53 | 0; // -12&gt; 生成6位数字验证码1234567891011// 方法一('000000' + Math.floor(Math.random() * 999999)).slice(-6);// 方法二Math.random().toString().slice(-6);// 方法三Math.random().toFixed(6).slice(-6);// 方法四'' + Math.floor(Math.random() * 999999); url查询参数转json格式12345678910111213141516171819// ES6const query = (search = '') =&gt; ((querystring = '') =&gt; (q =&gt; (querystring.split('&amp;').forEach(item =&gt; (kv =&gt; kv[0] &amp;&amp; (q[kv[0]] = kv[1]))(item.split('='))), q))(&#123;&#125;))(search.split('?')[1]);// 对应ES5实现var query = function(search) &#123; if (search === void 0) &#123; search = ''; &#125; return (function(querystring) &#123; if (querystring === void 0) &#123; querystring = ''; &#125; return (function(q) &#123; return (querystring.split('&amp;').forEach(function(item) &#123; return (function(kv) &#123; return kv[0] &amp;&amp; (q[kv[0]] = kv[1]); &#125;)(item.split('=')); &#125;), q); &#125;)(&#123;&#125;); &#125;)(search.split('?')[1]);&#125;;query('?key1=value1&amp;key2=value2'); // es6.html:14 &#123;key1: "value1", key2: "value2"&#125; 获取URL参数12345678function getQueryString(key)&#123; var reg = new RegExp("(^|&amp;)"+ key +"=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if(r!=null)&#123; return unescape(r[2]); &#125; return null;&#125; n维数组展开成一维数组1234567891011121314151617181920212223242526var foo = [1, [2, 3], ['4', 5, ['6',7,[8]]], [9], 10];// 方法一// 限制：数组项不能出现`,`，同时数组项全部变成了字符数字foo.toString().split(','); // ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]// 方法二// 转换后数组项全部变成数字了eval('[' + foo + ']'); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// 方法三，使用ES6展开操作符// 写法太过麻烦，太过死板[1, ...[2, 3], ...['4', 5, ...['6',7,...[8]]], ...[9], 10]; // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]// 方法四JSON.parse(`[$&#123;JSON.stringify(foo).replace(/\[|]/g, '')&#125;]`); // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]// 方法五const flatten = (ary) =&gt; ary.reduce((a, b) =&gt; a.concat(Array.isArray(b) ? flatten(b) : b), []);flatten(foo); // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]// 方法六function flatten(a) &#123; return Array.isArray(a) ? [].concat(...a.map(flatten)) : a;&#125;flatten(foo); // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10] 日期格式化12345678910111213141516171819202122232425262728293031323334353637383940// 方法一function format1(x, y) &#123; var z = &#123; y: x.getFullYear(), M: x.getMonth() + 1, d: x.getDate(), h: x.getHours(), m: x.getMinutes(), s: x.getSeconds() &#125;; return y.replace(/(y+|M+|d+|h+|m+|s+)/g, function(v) &#123; return ((v.length &gt; 1 ? "0" : "") + eval('z.' + v.slice(-1))).slice(-(v.length &gt; 2 ? v.length : 2)) &#125;);&#125;format1(new Date(), 'yy-M-d h:m:s'); // 17-10-14 22:14:41// 方法二Date.prototype.format = function (fmt) &#123; var o = &#123; "M+": this.getMonth() + 1, //月份 "d+": this.getDate(), //日 "h+": this.getHours(), //小时 "m+": this.getMinutes(), //分 "s+": this.getSeconds(), //秒 "q+": Math.floor((this.getMonth() + 3) / 3), //季度 "S": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); &#125; for (var k in o)&#123; if (new RegExp("(" + k + ")").test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); &#125; &#125; return fmt;&#125;new Date().format('yy-M-d h:m:s'); // 17-10-14 22:18:17 匿名函数自执行写法1234567891011121314151617181920( function() &#123;&#125;() );( function() &#123;&#125; )();[ function() &#123;&#125;() ];~ function() &#123;&#125;();! function() &#123;&#125;();+ function() &#123;&#125;();- function() &#123;&#125;();delete function() &#123;&#125;();typeof function() &#123;&#125;();void function() &#123;&#125;();new function() &#123;&#125;();new function() &#123;&#125;;var f = function() &#123;&#125;();1, function() &#123;&#125;();1 ^ function() &#123;&#125;();1 &gt; function() &#123;&#125;(); 数字字符转数字12var a = '1';+a; // 1 最短的代码实现数组去重1[...new Set([1, "1", 2, 1, 1, 3])]; // [1, "1", 2, 3]]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向学生的微信开发建议]]></title>
    <url>%2F2018%2F02%2F09%2F%E9%9D%A2%E5%90%91%E5%AD%A6%E7%94%9F%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[微信开发学习建议了解微信开发微信功能的实现主要依托期微信公众平台，即订阅号、服务号、企业号、小程序。功能对比。功能说明。 开发文档是主要参考文档，有所有能用的功能和实现说明 认证与未认证的订阅号/服务号接口权限区别很大。 学习过程中可以开通测试账号，无需认证就具备所有高级接口权限 开发建议准备 购买学生版服务器 腾讯云 阿里云 相对偏贵，性能好 装linux系统，推荐 ubuntu 推荐服务器软件管理软件 amh 注册个人域名并备案 通过Github管理个人项目 使用Google搜索（翻墙方案很多，建议自己找两三个同学合伙搭建翻墙服务器，推荐VPS服务商 vultr $2.5/月, 工具 shadowsocks） 学习流程 注册微信公众平台测试号 搭建服务器运行环境，解析域名 （ 必须，微信开发有域名安全机制，并能正常访问 ） 部署基础项目 实现微信登录功能 实现JS-SDK功能 实现微信支付功能（ 需要以公司名义开通，流程教复杂 ） 调试技巧 微信web开发者工具 在chrome的基础上输出更多调试信息 chrome 学会用谷歌浏览器调试 真机调试 页面在微信上对显示效果跟电脑上不完全一样，存在兼容性问题，这个时候，如果在本地开发，可以把本地启动对服务器暴露到局域网，用手机通过ip访问 开发模式：微信网页开发 （最常用）通过微信打开的页面能使用微信app提供的功能，相当于在常见页面里拓展一些功能，可以把微信理解成具有特殊功能的浏览器 常用的有 微信登录：订阅号/服务号都支持 微信支付：服务号支持 JS-SDK：微信打开的页面通过js调取微信app的拥有的功能,常用的有 分享页面 上传下载图片 扫一扫 微信交互开发在公众号界面通过聊天的形式进行交互 接受消息 回复消息 通知消息 APP开发在非微信app中调起微信登录和微信支付 开发流程 确定需求，注册合适的公众号 注册域名，服务器 配置微信公众号 （ 根据需要使用的微信功能进行配置，开发文档有说明 ） 选取合适的语言和框架 搭建开发环境 服务器软件 （ Apache / Nginx ） 语言运行环境 版本管理系统（ 方便代码管理和多人开发 Git / Svn ） 开发 测试 ( 测试覆盖面要全，极端值也需要测试 ) 上线 主要微信功能说明]]></content>
      <tags>
        <tag>web</tag>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周总结-17周]]></title>
    <url>%2F2018%2F01%2F01%2F%E5%91%A8%E6%80%BB%E7%BB%93-17%E5%91%A8%2F</url>
    <content type="text"><![CDATA[关于个人发展的思考想了很久，以论文/专利为出发点去写论文/专利对话，感觉无从下手，范围太广，盲目深钻很需要时间，就算写成，但不一定对将来发展有很好的帮助，主要是个人目前不打算往学术路上发展，以就业为主。个人发展规划是 前端工程师 &gt;&gt; 全栈工程师 &gt;&gt; 架构师。 主要目标打算还是依托产品去做点事情，目标是技术层面深入学习，同时能从中产生论文/专利/软著。目前我也没有比较满意的代表作品，尤其是前端领域的应用。项目对就业来说更有吸引力，面试对时候也更有说辞。保证在2018年秋招的时候达到一线公司的要求。 不足之处和侧重点目前有一些校内校外项目实践经验，有一定的技术架构能力，完成一个比较完善的产品没有太大问题，但是还是存在一些短板 前端技术还是不够精通，对于一些前端应用没有信手拈来对思路。 企业级架构建设上还有所缺乏，目前做的项目也没有涉及到，无法去实践，例如 Redis、mongodb、消息队列、容器技术、分布式部署、服务端渲染等等企业级应用。所以打算在接下来到项目中能去应用和实践，这也是架构师必须有的能力。 技术输出不够多，无法很好对现有的技术/思路进行总结和表达，博客维护不够多。 上述的都是接下来项目技术层面需要侧重注意的，即：前端的高级应用、企业级架构的实践以及技术产出 关于产品目前有几个产品方向 私人助理应用面向工作者的功能集成应用，统一碎片化功能，例如笔记，清单，运动，饮食，记账，备忘，语音控制 等等，结合云计算API可以实现很多日常适用的功能，相当于个人助理一样 跨平台：用JavaScript可以实现，提现前端能力 并发处理 企业架构实践 。。。 Node企业级框架目前Node还缺乏类似java的Spring、php的yii的框架，这个方向值得去尝试，但是难度很大，在技术界推广更是难以实现 React 组件库纯粹是前端应用，技术广度不够 2017年总结由于身体原因，最终做多事情不多，主要做的还是前端项目实践上，尤其是React的应用，值得去深入研究，也是未来方向。 2018年初步打算 上半年完成这个产品，尝试从中产生 论文/专利，并参与一些合适多比赛。 技术产出 准备好秋招]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阿里云视频上传在React中的实现]]></title>
    <url>%2F2017%2F12%2F20%2F%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91%E4%B8%8A%E4%BC%A0%E5%9C%A8React%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在原项目基础上进行了删减，用了antd UI库，能够显示当前上传进度，采用阿里云点播凭证方式上传，不是OSS的上传模式，可以根据官方demo进行调整 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160import React, &#123;Component&#125; from 'react';import &#123;Button, Col, Form, Icon, Input, message, Modal, Row, Select, Switch, Upload&#125; from 'antd';import &#123; loadServiceCourseDataSet, loadUploadVideoAuth, reloadUploadVideoAuth, updateServiceCourseItem&#125; from '../../../service/course';import LazyLoad from 'react-lazy-load';const FormItem = Form.Item;// 创建 上传实例 变量，多次尝试后放在这里才靠谱var uploader;class Update extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; fileList: [], aliVideoAuthDto: &#123; requestId: '', uploadAddress: '', uploadAuth: '', videoId: '' &#125;, upload_progress: '' &#125; &#125; componentDidMount() &#123; let _this = this; uploader = new VODUpload(&#123; // 文件上传失败 'onUploadFailed': function (uploadInfo, code, message) &#123; message.fail('上传失败，请稍后再试'); //console.log("onUploadFailed: file:" + uploadInfo.file.name + ",code:" + code + ", message:" + message); &#125;, // 文件上传完成 'onUploadSucceed': function (uploadInfo) &#123; _this.setState(&#123; uploading: false&#125;) message.success('上传成功'); //console.log("onUploadSucceed: " + uploadInfo.file.name + ", endpoint:" + uploadInfo.endpoint + ", bucket:" + uploadInfo.bucket + ", object:" + uploadInfo.object); &#125;, // 文件上传进度 'onUploadProgress': function (uploadInfo, totalSize, uploadedSize) &#123; //console.log("onUploadProgress:file:" + uploadInfo.file.name + ", fileSize:" + totalSize + ", percent:" + Math.ceil(uploadedSize * 100 / totalSize) + "%"); _this.setState(&#123; upload_progress: Math.ceil(uploadedSize * 100 / totalSize) + "%"&#125;) &#125;, // STS临时账号会过期，过期时触发函数 'onUploadTokenExpired': function () &#123; message.success('上传凭证过期，请重试'); //console.log("onUploadTokenExpired"); &#125;, // 开始上传 'onUploadstarted': function (uploadInfo) &#123; _this.setState(&#123; uploading: true &#125;); uploader.setUploadAuthAndAddress(uploadInfo, _this.state.aliVideoAuthDto.uploadAuth, _this.state.aliVideoAuthDto.uploadAddress); &#125; &#125;); uploader.init(); &#125; normFile = (e) =&gt; &#123; console.log('Upload event:', e); if (Array.isArray(e)) &#123; return e.file; &#125; return e &amp;&amp; e.fileList; &#125; doUpload = () =&gt; &#123; console.log('start'); uploader.startUpload(); &#125;; render() &#123; const &#123;getFieldDecorator&#125; = this.props.form; const formItemLayout = &#123; labelCol: &#123; xs: &#123;span: 24&#125;, sm: &#123;span: 4&#125;, &#125;, wrapperCol: &#123; xs: &#123;span: 24&#125;, sm: &#123;span: 18&#125;, &#125;, &#125;; const uploadProps = &#123; action: '//jsonplaceholder.typicode.com/posts/', onRemove: (file) =&gt; &#123; this.setState((&#123;fileList&#125;) =&gt; &#123; const index = fileList.indexOf(file); const newFileList = fileList.slice(); newFileList.splice(index, 1); return &#123; fileList: newFileList, &#125;; &#125;); &#125;, beforeUpload: (file) =&gt; &#123; let userData = '&#123;"Vod":&#123;"UserData":"&#123;"IsShowWaterMark":"false","Priority":"7"&#125;"&#125;&#125;'; console.log(file); this.setState(&#123;videoSize: file.size&#125;) uploader.addFile(file, null, null, null, userData); // 获取上传凭证 loadUploadVideoAuth(&#123; courseItemId: this.props.data.id, videoName: file.name, videoTitle: file.name, videoTags: file.name, videoDesc: file.name, &#125;).then(data =&gt; &#123; this.setState(&#123;aliVideoAuthDto: data.data.aliVideoAuthDto&#125;); &#125;); this.setState((&#123;fileList&#125;) =&gt; (&#123; fileList: [...fileList, file], &#125;)); return false; &#125;, fileList: this.state.fileList, &#125;; return ( &lt;Modal title="更新" visible=&#123;this.props.show&#125; onCancel=&#123;this.props.onCancel&#125; footer=&#123;null&#125; width=&#123;'80%'&#125;&gt; &lt;Row type='flex' style=&#123;&#123;marginBottom: '5px'&#125;&#125;&gt; &lt;Col span=&#123;24&#125;&gt; &lt;FormItem &#123;...formItemLayout&#125; label="课程视频"&gt; &lt;Upload &#123;...uploadProps&#125;&gt; &lt;Button&gt; &lt;Icon type="upload"/&gt; 选择文件 &lt;/Button&gt; &lt;/Upload&gt; &lt;Button type="primary" onClick=&#123;this.doUpload&#125; disabled=&#123;this.state.fileList.length === 0&#125; loading=&#123;this.state.uploading&#125;&gt; &#123;this.state.uploading ? this.state.upload_progress : '开始上传'&#125; &lt;/Button&gt; &lt;/FormItem&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;FormItem wrapperCol=&#123;&#123;span: 12, offset: 4&#125;&#125;&gt; &lt;Button type="primary" onClick=&#123;this.handleSubmit&#125;&gt;提交更新&lt;/Button&gt; &lt;/FormItem&gt; &lt;/Modal&gt; ) &#125;&#125;export default Form.create()(Update);]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云视频点播在React中的实现]]></title>
    <url>%2F2017%2F12%2F20%2F%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91%E7%82%B9%E6%92%AD%E5%9C%A8React%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在原项目组件上进行了删减，保留核心代码，不一定能直接运行，需要根据情况调整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import React, &#123; Component &#125; from 'react';import &#123; hashHistory &#125; from 'react-router';class CourseDetail extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; this.player = null; // 创建播放器实例变量 &#125; componentDidMount() &#123; // 初始化播放器, this.player = new Aliplayer(&#123; id: 'Ali_Player', // 容器id vid: '', width: "100%", // 播放器宽度 playauth: '', cover: `$&#123;IMG_DOMAIN&#125;$&#123;data.data.serviceCourseDto.serviceCourse.coverUrl&#125;`, autoplay: false, rePlay: false, skinLayout:[&#123;"name":"H5Loading","align":"cc"&#125;, &#123;"name":"errorDisplay","align":"tlabs","x":0,"y":0&#125;, &#123;"name":"infoDisplay","align":"cc"&#125;, &#123;"name":"controlBar","align":"blabs","x":0,"y":0,"children":[&#123;"name":"progress","align":"tlabs","x":0,"y":0&#125;, &#123;"name":"timeDisplay","align":"tl","x":10,"y":24&#125;]&#125;] &#125;); this.player.on('play',()=&gt;&#123; if(this.state.cur_courseitem.courseItemId)&#123; this.player.play(); &#125; else &#123; this.player.pause(); Toast.info('请选择章节'); &#125; &#125;) &#125; handlePlay = (courseItemId) =&gt; &#123; // 播放事件，此时获取播放凭证，也可以在挂载的时候获取播放凭证 loadVideoPalyAuth(&#123;courseItemId&#125;).then(data =&gt; &#123; this.setState(&#123; cur_courseitem: &#123; ...this.state.cur_courseitem, videoId: data.data.aliVideoPlayAuthDto.videoId, playauth: data.data.aliVideoPlayAuthDto.playAuth, courseItemId: courseItemId &#125; &#125;,()=&gt;&#123; if (this.player)&#123; this.player.dispose(); &#125; this.player = new Aliplayer(&#123; id: 'Ali_Player', // 容器id vid: data.data.aliVideoPlayAuthDto.videoId, width: "100%", // 播放器宽度 playauth: data.data.aliVideoPlayAuthDto.playAuth, autoplay: false, rePlay: false, &#125;); &#125;); &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handlePlay&#125;&gt;播放&lt;/button&gt; &lt;div className="prism-player" id='Ali_Player' /&gt; &lt;/div&gt; ); &#125;&#125;export default CourseDetail;]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周总结-15周]]></title>
    <url>%2F2017%2F12%2F17%2F%E5%91%A8%E6%80%BB%E7%BB%93-15%E5%91%A8%2F</url>
    <content type="text"><![CDATA[本周概况任务完成情况 继续：完成一篇技术博文：阿里云视频点播在React中的实现 需要继续完善 完成经英教育扫尾工作 基本完成，根据下周反应情况继续微调 完成视频监控小项目 基本完成，截图功能需要继续研究和实现，根据反应完善 下周安排 结合时间，方向，对比论文和专利，确定下一步学术工作（主要） 之前搁置了一篇论文，方向是流数据处理，需要重新考虑一下究竟是论文还是专利更适合现阶段去做。有过一篇论文经验，但是对专利的发表比较陌生，需要详细了解。]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[周总结-14周]]></title>
    <url>%2F2017%2F12%2F10%2F%E5%91%A8%E6%80%BB%E7%BB%93-14%E5%91%A8%2F</url>
    <content type="text"><![CDATA[本周概况任务完成情况 创建个人React组件库项目，整合目前个人具有代表性的组件 已经完成，已经整合的有 Ueditor， Github地址：https://github.com/Houserqu/react-component 了解在线测评系统，并总结其前端基于react的最佳实现 网上没有现成方案，需要开发。目前方案：服务端返回所有题目，前端渲染成左右切换式，每次完成一题，请求后端创建记录，切换下一题。服务端会记录每一题的完成情况 了解数据挖掘，研究应用于*图网的可行性 带水印图片是固定链接，由目录、分类id、分辨路构成，无水印原图由目录、分类id、加密字符串构成，该字符串与用户有关，是突破难点 完成一篇技术博文：阿里云视频点播在React中的实现 未完成。。。 下周安排 继续：完成一篇技术博文：阿里云视频点播在React中的实现 完成经英教育扫尾工作（主要） 完成视频监控小项目 （主要） 完成至少一半网络原理需要补交的作业]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[周总结-13周]]></title>
    <url>%2F2017%2F12%2F03%2F%E5%91%A8%E6%80%BB%E7%BB%93-13%E5%91%A8%2F</url>
    <content type="text"><![CDATA[本周概况 初步完成 经英教育 项目 英语强化学习计划 操作系统使用英文语言 日常新闻使用BBC 周报使用英文 日常文档优先使用英文版 下周安排 创建个人React组件库项目，整合目前个人具有代表性的组件 了解在线测评系统，并总结其前端基于react的最佳实现 了解数据挖掘，研究应用于摄图网的可行性 完成一篇技术博文：阿里云视频点播在React中的实现]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[周总结-12周]]></title>
    <url>%2F2017%2F11%2F26%2F%E5%91%A8%E6%80%BB%E7%BB%93-12%E5%91%A8%2F</url>
    <content type="text"><![CDATA[本周概况 研究调试微信支付功能，熟悉微信支付原理和流程，并成功应用 研究学习 React 框架 学习编译原理 解决视频播放在 react 组件中实例化问题 下周安排 继续 经英教育 微信项目的开发 继续学习 编译原理 制定英语锻炼计划，并将一些日常学习工作英文化]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[周总结-11周]]></title>
    <url>%2F2017%2F11%2F19%2F%E5%91%A8%E6%80%BB%E7%BB%93-11%E5%91%A8%2F</url>
    <content type="text"><![CDATA[本周概况 继续 经英教育 项目并完成基本项目架构以及页面规划 完成部分 学院官网 扫描的漏洞问题 下周安排 继续 经英教育 项目的开发 复习 编译原理，准备第13周的考试 完成各科需要补交的作业]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周总结-10周]]></title>
    <url>%2F2017%2F11%2F08%2F%E5%91%A8%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[本周概况 完成 水墨人生 JSSDK相关功能的开发以及一些收尾工作 开启 经英教育 项目并完成基本项目架构以及页面规划 完成复学相关手续 下周安排 继续 经英教育 项目的开发 完善 react-cli 脚手架项目 完成 学院官网 扫描的漏洞问题]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人总结的react脚手架]]></title>
    <url>%2F2017%2F09%2F07%2F%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E7%9A%84react%E8%84%9A%E6%89%8B%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[react-clireact应用的起步工程和总结 Github传送门 特点采用时下流行的技术栈，视图：react，状态管理：redux，路由：react-router 作为基础，配合webpack等开发工具而搭建的项目架构，适用于中小型项目，也可以在此基础上进行调整适合更多类型的项目。 同时还会提供react开发相关的资料、疑问、解决方案等，希望对开发者有所帮助，也对自己的技术有所提升。欢迎大家提供建议 技术栈 react redux react-router mock pace whatwg-fetch 项目构建目录结构123456789101112131415161718192021222324252627282930313233343536.├── README.md├── build #构建生成目录│ ├── bundle │ └── index.html├── package-lock.json├── package.json├── src #源代码文件│ ├── action.js #action创建函数文件│ ├── components #组件目录 *1│ │ ├── layout│ │ └── notify│ ├── http.js #所有fetch请求 *2│ ├── index.html #webpack生成html的模板 *3│ ├── index.js #入口文件│ ├── reducer.js #reducer *4│ ├── router.js #路由定义│ ├── routes #路由对应的page目录│ │ ├── App.js #入口文件 *5│ │ ├── index #一个页面对应一个文件夹 *6│ │ │ ├── Index.js│ │ │ └── index.scss│ │ └── login│ │ ├── Login.js│ │ └── login.scss│ ├── static #静态文件夹│ │ └── logo.jpg│ ├── store.js #store创建文件 *7│ └── utils #工具集│ ├── config.js #项目配置│ ├── mock.js #本地mock数据│ ├── pace.css #首屏加载动画css│ ├── pace.js #首屏加载动画js│ └── theme.scss #主题sass变量├── webpack.config.js #webpack开发配置文件└── webpack.production.config.js #webpack构建配置文件 目录结构说明 components 每一个组件对应一个文件夹，包含该组件js以及css，更小的组件也放在该文件夹下 将所有的请求独立出来放在一个文件里，每个fetch请求封装成一个回调函数并export 采用自定义html模板进行打包便于引用cdn等文件，或者其他自定义操作 项目复杂的时候可以创建reducer文件夹，进一步拆分 每个页面都是该组件的字组件，便于引入例如通知等全局组件 每个页面对应一个文件夹，因为一个页面包含的组件较多，利于拆分 独立出来store是便于在非组件的文件中操作reducer的store 开发说明克隆项目: 1git clone https://github.com/Houserqu/react-cli.git 进入项目目录安装依赖: 1npm i 开发: 1npm run dev 构建: 1npm run build]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
        <tag>webpack</tag>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曲折回学路]]></title>
    <url>%2F2017%2F09%2F05%2F%E6%9B%B2%E6%8A%98%E5%9B%9E%E5%AD%A6%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[时隔五个月，终于再次回到学校，从去年12月份检查出病到现在，居然已经有十余月，真的不知道是如何走到现在的。这次病魔缠身，对我身体和精神带来了巨大打击，对家人也是带来了沉重的负担，感触颇深，希望对生命有重新的认识吧。不彻底痛苦一次，就不会知道生活恶习所引发的蝴蝶效应。 虽然已经回到学校，但似乎还没有那么顺利上课，治疗时间还没有达到规定，只好按规定办事了。 左手静脉血管上扎的疤痕依旧清晰可见，一天大把的药还需要服用，革命尚未成功！只能告诫自己好好爱惜身体吧。 这次回校真的激动万分，见到了等待已久的她，见到了高谈阔论的室友。生活很美好！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[fetch post formData]]></title>
    <url>%2F2017%2F08%2F18%2Ffetch-post-formData%2F</url>
    <content type="text"><![CDATA[当使用fetch用表单的方式post json类型的数据时候，需要注意几个问题 header设置header 的 ‘Content-Type’,’application/x-www-form-urlencoded;charset=utf-8’ 序列化json尝试过多种方式，需要处理成 ‘username=admin&amp;password=password’这种方式才能被正确的识别成 formData格式，可以在浏览器查看具体的请求体采用类似 new FormData() 方式会被处理成——WebKitFormBoundary 具体示例 1234567891011121314151617//序列化jsonconst formBody = Object.keys(paramsArray).map(key=&gt;encodeURIComponent(key)+'='+encodeURIComponent(paramsArray[key])) .join('&amp;');var headers = new Headers();headers.set('Content-Type','application/x-www-form-urlencoded;charset=utf-8');fetch('api/auth/login',&#123; method:'post', mode:'cors', credentials: "include", headers, body: formBody&#125;).then((response)=&gt;&#123; return response.json(); &#125;).then((responseData)=&gt;&#123; console.log(responseData);&#125;); 参考：四种常见的 POST 提交数据方式how to post a x-www-form-urlencoded request from react-nativeHow to make a post request with JSON data in application/x-www-form-urlencoded]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX/Fetch 在跨域情况下发送cookie并保持 sessionid一致]]></title>
    <url>%2F2017%2F08%2F18%2FAJAX-Fetch%E5%9C%A8%E8%B7%A8%E5%9F%9F%E6%83%85%E5%86%B5%E5%8F%91%E9%80%81cookie%E5%B9%B6%E4%BF%9D%E6%8C%81sessionid%E4%B8%80%E8%87%B4%2F</url>
    <content type="text"><![CDATA[Ajaxajax在跨域发送请求的时候需要添加 xhrFields 12345678910111213$.ajax(&#123; url:'example.com', method:'post', datatype:'json', xhrFields: &#123; withCredentials: true &#125;, crossDomain: true, data:param, success:function(data)&#123; console.log(data); &#125; &#125;) Fetchfetch在跨域发送请求的时候需要添加 credentials: “include” 12345678910fetch('http://example.com',&#123; method:'post', mode:'cors', credentials: "include", body: param&#125;).then((response)=&gt;&#123; return response.json(); &#125;).then((responseData)=&gt;&#123; console.log(responseData);&#125;); 参考：Ajax跨域请求，同时保证session一致Fetch API with Cookie]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ajax</tag>
        <tag>fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换新的Blog系统]]></title>
    <url>%2F2017%2F08%2F06%2F%E6%9B%B4%E6%8D%A2%E6%96%B0%E7%9A%84Blog%2F</url>
    <content type="text"><![CDATA[经过长时间的调研，钻研，新的blog系统终于上线了 从wordpress，到个人用react+laravel开发，到现在的github pages 觉得目前的模式还是挺不错的，github，nodejs，markdown都是我非常喜欢的技术，这三者的结合希望能给我带来愉快的码字体验 当然最重要的还是多敲多写 好记性不如烂指头]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node</tag>
      </tags>
  </entry>
</search>
