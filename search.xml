<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【读书笔记】React 设计模式与最佳实践]]></title>
    <url>%2F2018%2F10%2F28%2F%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91React-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[发现一本还不错的 react 相关的书，《React 设计模式与最佳实践》，第一版是 18 年 8 月份的，比较新，目测适合入门和巩固 React 开发的人，更加全面的了解 React 的开发，不涉及到源码解读等。这里记录一下阅读后我不熟悉的或值得记录的点。 JSXjsx 中插入多空格&lt;div&gt;a{&quot; &quot;}b{&quot; &quot;}c&lt;/div&gt; 条件渲染很多时候需要根据条件判断是否需要渲染某个组件，常常我们会这样写： 1&lt;div&gt;&#123;dataIsReady &amp;&amp; (isAdmin || userHasPermissions) &amp;&amp; &lt;SecretData /&gt;&#125;&lt;/div&gt; 如果条件比较复杂，可以抽离出判断规则为一个方法： this.isRender &amp;&amp; &lt;SecretData /&gt;。为了保证组件的纯净，可以使用 react-only-if 这个库，能够快速的创建出根据条件渲染的高阶组件。 展开属性属性可以直接传入一个展开的对象，不用一个一个对应再写一遍 &lt;button {...props} /&gt; getterage(){} =&gt; get age()，使用的时候可以省略括号，相当于一个值，可以类比为 vue 中的计算属性。 动画推荐一个库react-transition-group，能够更方便的控制多个状态。 性能优化环境用 webpack 打包的时候区分好生产环境和开发环境。 函数式组件该类型组件没有实例化过程，所以没有自己的生命周期和状态，适合用来构建大型的组件，因为耦合度更低。多使用函数式组件能够让思路更清晰。 手动控制组件更新合理使用 shouldComponentUpdate() 方法和 PureComponent 组件，减少没必要的组件更新。 props 常量对象将一个常量对象作为 props 时最好在外部创建，通过引用传入，而不是在属性上创建，同理绑定 props 方法时也是这样。这样能够避免每次 update 都重复创建，以及在循环中重复创建。 bad: 12&lt;Com status=&#123;[1: 'a', 2: 'b']&#125; /&gt;&lt;Com status=&#123;() =&gt; &#123;&#125;&#125; /&gt; good: 12&lt;Com status=&#123;this.status&#125; /&gt;&lt;Com status=&#123;this.fun&#125; /&gt; 代码风格强烈建议项目中加入 eslint 等代码风格检查工具，配合 ide 插件能够实时提醒，保证多人开发的时候看到的代码是一致的。另外推荐 prettier，一个代码自动格式化工具，eslint 虽然提示了，但是自己手动修改也是麻烦，该库能够根据 eslint 配置或者个人配置自动格式化代码，完美搭档。 函数式编程我个人的理解是运用柯里化、组合、链式调用等技巧写出没有副作用、简单明了、易于维护的代码。而 es6 可以很方便的实现这几个技巧。 CSSCSS 是前端开发无法避免的话题，文中提到几个 css 写法：Css in JavaScript、 style、 Radium，其实这三个都是都是行内样式的写法，实际开发时并不推荐，样式不好复用，相当于阉割版 css，无法使用 less/scss 等优秀的预处理器。个人觉得最合适的还是 CSS Module，灵活，纯正。 服务端渲染一直没有去尝试做这个，服务端渲染技术能够改善 SEO 和首屏加载速度，因为首屏页面是在服务端进行的，而不是浏览器端，这样页面能够更快速的呈现。实现需要后端配合。 测试与调试目前我都没有在项目中写个测试，对于 react 组件，测试写起来比较繁琐，而且变化也很频繁，的确让人容易怯步，后续可以考虑一下，或许需要重新审视一下测试。 react 调试比较有用的是 react-devtools 和 redux-devtools，前者调试组件，后者调试 redux]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【分享】33 Concepts Every JavaScript Developer Should Know]]></title>
    <url>%2F2018%2F10%2F21%2F33-Concepts-Every-JavaScript-Developer-Should-Know%2F</url>
    <content type="text"><![CDATA[这周 Javascript Weekly 给我推送了一个很不错的文章，也可以说是个项目：33 Concepts Every JavaScript Developer Should Know ，即《每个 JavaScript开发者都应该知道的 33 个概念》。该项目的是根据 Stephen Curtis 发表的一篇文章《33 Fundamentals Every JavaScript Developer Should Know》提到的概念对应的收集了相关的文章和视频，便于开发者了解和学习。 本文列出提到的 33 个概念，详细内容去项目github查看 Call Stack 调用栈 Primitive Types 原始类型 Value Types and Reference Types 值类型和引用类型 Implicit, Explicit, Nominal, Structuring and Duck Typing 隐式，显式，名义，结构和鸭子类型 == vs === vs typeof Function Scope, Block Scope and Lexical Scope 方法作用域，块作用域，词法作用域 Expression vs Statement 表达式 vs 语句 IIFE, Modules and Namespaces 立即执行函数，模块，命名空间 Message Queue and Event Loop 消息队列和事件轮询 setTimeout, setInterval and requestAnimationFrame 定时器，循环执行，动画帧方法 JavaScript Engines JavaScript 引擎 Bitwise Operators, Type Arrays and Array Buffers 位运算符，类型数组 DOM and Layout Trees DOM树和结构树 Factories and Classes 工厂方法和类 this, call, apply and bind new, Constructor, instanceof and Instances Prototype Inheritance and Prototype Chain 原型继承和原型链 Object.create and Object.assign map, reduce, filter Pure Functions, Side Effects and State Mutation 纯函数，副作用，状态突变 Closures 闭包 High Order Functions 高阶函数 Recursion 递归 Collections 集合 Promises async/await Data Structures 数据结构 Expensive Operation and Big O Notation 高开销操作和复杂度 Algorithms 算法 Inheritance, Polymorphism and Code Reuse 继承，多态和复用 Design Patterns 设计模式 Partial Applications, Currying, Compose and Pipe 部分函数应用，柯里化，组合和链式调用 Clean Code 代码整洁]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-4]]></title>
    <url>%2F2018%2F09%2F26%2F%E7%AC%94%E8%AE%B0-4%2F</url>
    <content type="text"><![CDATA[getBoundingClientRect()需求：判断页面是否已经阅读完；思路：判断某个元素是否在视口中，dom 对象有 getBoundingClientRect()，能够得到该元素相对视口的距离，从而判断元素是否被看到。 https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect 微信浏览器内 唤起 App`基本上无法实现，微信限制了该功能。 微信 JSSDK未公开的一篇文档，提到过一个 Birdge getInstallState 获取某app是否已安装 不过这是一个未公开的方法，不建议使用。 https://segmentfault.com/a/1190000012940046 文字渐变可以参考这个 demo，需要注意兼容性 http://demo.doyoe.com/css3/text-fill-color/gradient-text.htm img 之间有缝隙多个 img 自动换行显示的时候，上下相邻的图片会出现间隙，即使 margin:0，比较简单的方式是让 img 的 display: block；其他解决方法和导致原因参考链接 https://www.cnblogs.com/JoannaQ/archive/2013/03/16/2962443.html iphone 网页安全区iPhone X 的出现导致页面显示区没那没规则，为了保证在 这种机器上显示正常，可以借助 webkit 内核浏览器提供的特殊方法获取到 ‘不安全的区域的尺寸’，从而做兼容性处理。 https://aotu.io/notes/2017/11/27/iphonex/index.html]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-3]]></title>
    <url>%2F2018%2F09%2F18%2F%E7%AC%94%E8%AE%B0-3%2F</url>
    <content type="text"><![CDATA[循环异步处理12345678910const promises = data.map(async item =&gt; &#123; const res = await fetchLogisticsI(&#123; expressNo: item.expressNo, &#125;); if (res.success) &#123; expressList.push(res.results); &#125;&#125;);await Promise.all(promises); https://zhuanlan.zhihu.com/p/31000936 英语学习总结react router 切换路由不刷新最近遇到一问题，从一个列表页进入详情页，希望再从详情页返回列表页的时候列表页不要刷新，即不再走Mount阶段，组件不要被销毁，因为进入详情页面再返回的操作并不会导致列表数据的更新，而且该列表数据比较复杂，状态较多，渲染成本和数据回显成本较大。查询后发现，路由的切换一定会导致该路由下的组件 unmount。最后处理方式是将数据都放在 redux 里保存，返回后重新渲染。希望有更好的方式。 html 中的层叠关系html 会遇到需要控制元素显示层级的时候，例如悬浮的按钮，下拉弹窗等。如果需要判断两个元素的层级高低，先判断这些元素是否在同一个 层叠上下文 ，如果在，则判断 层叠顺序 ，如果不在，则判断各自所处的层叠上下文的 层叠顺序。 产生层叠上下文（部分）： position: absolute | relative; z-index: 非 auto; position: fixed | sticky; display: flex | inline-flex; z-index: 非 auto; 层叠顺序：正 z-index &gt; z-index: 0 &gt; inline-block &gt; float &gt; block &gt; 负 z-index &gt; background 和 border 详细讲解见参考链接 https://juejin.im/post/5ba4efe36fb9a05cf52ac192 react 设计模式与最佳实践发现一本还不错的 react 相关的书，《React 设计模式与最佳实践》，第一版是18年8月份的，比较新，目测适合入门和巩固 React 开发的人，更加全面的了解 React 的开发，应该不涉及到源码解读等。后续打算整理成一篇博文，记录一下重点。 用 Vultr 搭建 shadowsocks最近看到 vultr 服务器提供商有新注册送25美元的活动，打算在此mark一下。 对于程序员来说怎么能不翻墙呢。个人翻墙最方便的方式是用 shadowsocks，不过需要专门的海外服务器搭建shadowsocks服务端。目前流行两种方案： 购买别人搭建好了的服务，与别人共享一台服务器和带宽，这种方式省事，便宜。 自己购买 vps，搭建 shadowsocks服务。 对于开发者来说，建议后者，搭建服务并不难，有教程，在此提供一个不错的教程，自己搭建的服务器比较放心，安全，而且可以做些其他的用途，放些网站等。Vultr 我用了很久，比较稳定，最近有新用户充 $10 送 $25 的活动，值得下手，最便宜的 $2.5 / 月]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[笔记-2]]></title>
    <url>%2F2018%2F09%2F09%2F%E7%AC%94%E8%AE%B0-2%2F</url>
    <content type="text"><![CDATA[Disqus 代理配置准备将我的博客的评论功能从畅言换成 disqus，因为前者太难看了，但是 disqus 不翻墙的情况下无法访问，所以需要做点处理，可以使用如下方式。 https://github.com/ciqulover/disqus-proxyhttps://github.com/ciqulover/disqus-proxy-server 本地 nginx 代理我们公司的前后端分离方式是将前端部分的请求转发到开发者电脑的服务上，开发前访问携带本机 ip 访问指定请求，后端将 ip 写入 cookie，本机进行单页应用开发的时候会启动本地服务，后续本机访问 web 页面时，服务端会将页面 js 等相关的请求转发到本地上，而 ajax 请求不转发，从而实现前端本地开发和调试。 然而，存在部分 api 也被转发到了前端开发者本地电脑上，导致接口无法正常访问，因为前端本机只有前端相关资源，该 api 无法整处理。与同事讨论后有两种解决方案： 用 Charles (Mac) 进行拦截，不过没有尝试。 本地开启 nginx 进行代理，符合条件的路径转发到指定域名上去。 如上两种方式，本质上都是做一个请求拦截，符合条件的请求转发到正确的路径上去。 英语学习指导逛 Github 的时候无意间发现了一个 repository, 叫 English-level-up-tips-for-Chinese，让我意外的是居然也有 1 万多 start，大概浏览了一遍，感觉蛮受用，刚好现在一直有打算学号英语的心愿。在此 mark 一下。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[周记-业精于勤]]></title>
    <url>%2F2018%2F09%2F09%2F%E7%AC%94%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[业精于勤，荒于嬉；行成于思，毁于随 前言关于周记最近老是想起这句话，总觉得自己走在“荒于嬉，毁于随”的路上。一周下来感觉自己脑子空空的，除了工作周报上的几行记录，我再也想不出我做了什么。知乎刷了数百上千条，也没觉得见识上长见了多少。上一篇博客竟然是三个月前，半途而废的事情我倒是能列出一大堆，两周前就应该完成的那篇 blog、每晚的跑步计划… 这种状态我是憎恨的，让我整天过得 恍恍惚惚，每周过得 碌碌无为。仔细想想主要是这些原因： 时间花在无意义的事情上 新知识缺乏沉淀而导致遗忘 持之以恒的毅力和自控力 早就该反省自己了，现在也是时候去改变了，所以打算提出周记系列的 blog。因为每周都在工作，也有零碎的时间去学习，总有值得记录的东西，不求多，但求精，记录下来周末回顾。以前在学校的时候，马老师也是强制我们写实验室周报，然而离开学校后，也没有养成这个习惯，枉费马老师苦心。是时候重拾起来了。 实现流程一篇周记的完成是个持续的过程，是一周所有记录的入口，就把他当做草稿纸，遇到什么就写什么，然后周末整理成完整有序的文章，至此一篇周记结束。创建下一个循环。 利用好 Pocket 进行在线资源收藏，记录过程中难免有网上参考的内容，这个产品可以处理得很好。 每一篇周记需要有个独一无二的名字，格式：周记-*。 不强求每周一篇，但是希望能每周一篇，或者说称为阶段性总结更合适吧，这个阶段不能太长，也不能太短。 正文这次打算记录如下三个知识点，后两个知识点是需要深入研究的，暂且记录一下吧。 Css 中的长度/尺寸单位长度/尺寸单位分为相对单位和绝对值单位 绝对单位mm, cm, in: 毫米（Millimeters），厘米（centimeters），英寸（inches）pt, pc: 点（Points (1/72 of an inch)）， 十二点活字（ picas (12 points.)） 相对单位em: 相对 当前元素 font-size 尺寸的倍数，1em = 1倍。rem: 相对 根元素 font-size 尺寸的倍数，1rem = 1倍，根元素一般是 ，ie11+ 完全兼容ex, ch: 分别是小写x的高度和数字0的宽度，所以值与字体相关，一般用于文字微调，兼容性不友好。vw, vh: 分别是视口宽度的1/100和视口高度的1/100，兼容性不友好。 参考CSS的值和单位七个你可能不了解的CSS单位 Javascript 设计模式设计模式是软件中常会提到的东西，通俗点就是解决问题的方式，js 是通过原型链继承的，所以有些模式的实现细节跟 java 等语言不太一样，而且前端一般业务代码中运营较少，框架层面的开发的话会应用较多，之前自己实现的 Jayce 框架就运用到了 单例模式 、 职责链模式 和 发布订阅模式。其实很多时候也会无意间写出模式，只是没发现而已。再次记录一些曾看过而且还不错的文章吧，以供后续查阅。 个人觉得想要掌握各种设计模式，还是需要写一个复杂的应用才行，尤其是框架这种，因为只有你的代码足够复杂，才会需要用设计模式去优化你的代码。 图说设计模式详解 Javascript十大常用设计模式 网络通信过程虽然学过网络原理，不过已经忘得一干二净，回头再去看的时候，却不知如何开始，网络涉及的知识很多，我觉得首先得了解网络的通讯过程，即在应用层的请求到回复会发生哪些事情。《网络通信过程》 这篇文章对流程讲解还不错，能初步了解全貌。 web 开发有个经典的问题：从输入url到显示页面会经历哪些过程？网络通讯过程在该问题的整个过程占有非常重要的一环，回答上也是绕不过去的。该问题也打算整理成一篇 blog，正在进行中。《当你在浏览器中输入 baidu.com 并且按下回车后发生了什么？》这篇文章值得参阅。 后记 有始有终]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【笔记】本地引用开发中的npm包]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%9C%AC%E5%9C%B0%E5%BC%95%E7%94%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84npm%E5%8C%85%2F</url>
    <content type="text"><![CDATA[问题最近遇到一个情况，正在开发一个npm包，但是这个包是配合react使用的，而这个包是单独作为项目开发的，也需要发布到npm上去，但是在开发过程中需要结合react项目进行调试等，通过修改再发布到npm，react项目中再install的方式肯定不方便，所以问题来了，如何在一个项目中引入本地正在开发的package呢？ 解决方法其实npm自带了这个功能：npm link，npm link会将一个package添加到npm全局环境中，然后再需要使用的地方链接到node_modules目录中去。 还有其他解决方法，不过最方便的还是这个方式。 用法假设开发的package name 为 example-package，即package.json里的name字段值。 在正在开发的package目录中执行npm link 在需要引入这个package项目中执行 npm link example-package 然后就通过软连接的方式引入这个包了，你在原目录修改这个包都会同步到项目中去。 参考 你所不知道的模块调试技巧]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人开源项目 - Jayce:用WebSocket构建实时单页应用]]></title>
    <url>%2F2018%2F06%2F07%2F%E4%B8%AA%E4%BA%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-Jayce-%E7%94%A8WebSocket%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%97%B6%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Aboutbirth个人比较对实时性的应用比较感兴趣，而自己是个前端爱好者，非常喜欢基于react的单页应用开发，于是想能否结合react高点事情呢？于是诞生了开发Jayce这个框架的想法，一句话描述就是: 基于websocket的实时单页应用开发框架 Jayce可以让开发者用node.js + websocket + redux + react 开发出能够灵活的、健壮的、复杂的实时web应用，让程序员有更多时间喝咖啡。:coffee: :coffee: progress经过了大半个月的设计和开发，目前开发出了非常基础的版本，完成了核心架构的开发，基本上能够完成需要的功能。但是目前只是个婴儿，还不能用于正式项目中。 目前相当于踏出了第一步，后续还有很长的路要走。:muscle: :muscle: :muscle: InstallationJayce由三个子框架组成：jayce、jayce-dom、jayce-server，与其对应的npm包为 jayce-fe、jayce-dom、jayce-server jayce-fe与jayce-dom用于前端部分，jayce-server用于服务端 前端项目安装: 1npm i jayce-fe jayce-dom --save 服务端安装 1npm i jayce-server --save Documention由于框架还有很多部分需要完善，暂时还没有编写开发文档，关于框架的详细介绍，可以看这一篇文章 LicenseJayce is MIT licensed.]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
        <tag>前端</tag>
        <tag>websocket</tag>
        <tag>spa</tag>
        <tag>nodejs</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router-v4 路由监听]]></title>
    <url>%2F2018%2F05%2F31%2Freact-router-v4-%E8%B7%AF%E7%94%B1%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[在使用react的时候，会有需要监听react-router路由变化的需求，针对特殊路由进行处理等。 一种方案是将所有的路由组件都放在一个父组件里面，然后通过父组件的 this.props.location.pathname 进行手动获取。 如果结合redux存储的话可以使用 react-redux-router这个库。 最直接的方案是 使用 history 对象，react-router 也是基于这个 history 库实现的。 引入history库并实例化history对象，添加监听方法，然后传入到 的history属性中。 示例代码： 123456789101112131415161718192021222324252627282930import React from 'react';import ReactDOM from 'react-dom';import createHashHistory from "history/createHashHistory"import &#123; Router, Route, Link, Switch&#125; from 'react-router-dom';const history = createHashHistory()history.listen((location, action) =&gt; &#123; console.log( `The current URL is $&#123;location.pathname&#125;$&#123;location.search&#125;$&#123;location.hash&#125;` ) console.log(`The last navigation action was $&#123;action&#125;`)&#125;)ReactDOM.render( &lt;Router history=&#123;history&#125;&gt; &lt;div&gt; &lt;App /&gt; &lt;Switch&gt; &lt;Route exact path="/" component=&#123;Home&#125;/&gt; &lt;Route component=&#123;NoMatch&#125;/&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/Router&gt;, document.getElementById('root'));registerServiceWorker();]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的阿里云幸运券]]></title>
    <url>%2F2018%2F05%2F25%2F%E6%88%91%E7%9A%84%E9%98%BF%E9%87%8C%E4%BA%91%E5%B9%B8%E8%BF%90%E5%88%B8%2F</url>
    <content type="text"><![CDATA[最近经常购买阿里云的产品，发现阿里云有幸运券这个东西，于是自己也申请了个阿里云大大使，在此提供我的阿里云幸运券。注意我的名称：houserqu@qq.com 立即领券 使用说明 进入领取页面领取需要的产品幸运券，建议一键领取 只能在新购和升级产品的时候抵用！！！ 有效期：幸运券自领取之日（含）三十天内有效。 在幸运券有效期内会默认优先使用第1个领取的幸运券（但有权选择使用谁的幸运券） 幸运券可以和其他优惠（包含但不限于官网折扣、代金券、储值卡等）同时使用。 了解更多关于云大使问题]]></content>
      <tags>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给自己的项目取个与国际接轨的名字吧！]]></title>
    <url>%2F2018%2F05%2F14%2F%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%8F%96%E4%B8%AA%E4%B8%8E%E5%9B%BD%E9%99%85%E6%8E%A5%E8%BD%A8%E7%9A%84%E5%90%8D%E5%AD%97%E5%90%A7%EF%BC%81%2F</url>
    <content type="text"><![CDATA[最近需要开启一个新的项目，本开始就是用各种核心技术连接在一起。回头一看真是感觉毫无特色啊，而且还老长老长，依然无法描述出这个项目到底是干啥的，既然如此，还不如还不如取个简短个性的名称，说不定某一天这个项目就火了呢！ 网上搜了一波，可以从这些角度入手。除非预知项目一定会火，不建议创建新的单词。选好名字后去github搜索一下，没有重名就可以考虑使用了。 动物名称推荐一个动物检索网站 成功示例 python :大蟒蛇 游戏角色名称魔兽角色名称检索 成功示例 Druid : 德鲁伊 中国风麒麟 盘古 女娲… 各种电影,小说的角色名]]></content>
      <tags>
        <tag>github</tag>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人Wiki]]></title>
    <url>%2F2018%2F05%2F04%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAWiki%2F</url>
    <content type="text"><![CDATA[日常开发中会遇到值得记录的东西，发在博客中意义不大，对读者来说降低了博客质量，而且太零散，不成体系，所以有必要搭建个人知识管理系统。 需求 通过git进行版本控制 markdown编写 能够以web发布供别人访问 首先考虑的是 GitBook ，然后国内访问效果不太理想，即使翻墙也很慢，只好放弃。 hexo这种模式也不错，但是其针对还是blog，无法层级式的管理内容。 最适合替代 GitBook 的目前来看只有 看云 了。功能基本完善，最终选择了看云。 可以通过左边导航进入我的 Wiki。 欢迎指教。]]></content>
  </entry>
  <entry>
    <title><![CDATA[covert dom node list in IE]]></title>
    <url>%2F2018%2F05%2F03%2Fcovert-dom-node-list-in-IE%2F</url>
    <content type="text"><![CDATA[如需将 DomCollection 转换成Array, 常用的方法是 Array.prototype.slice.call(list,0)。不过在IE下无法工作，应为DOMCollection对象与标准的Dom对象不同。建议用额外的方法去完成，从而保证兼容性. 12345678function toArray(obj) &#123; var array = []; // iterate backwards ensuring that length is an UInt32 for (var i = obj.length &gt;&gt;&gt; 0; i--;) &#123; array[i] = obj[i]; &#125; return array;&#125; 参考 How to convert a DOM node list to an array in Javascript?Array.prototype.slice.call()方法详解]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>DOM</tag>
        <tag>ie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[create-react-app 配置多页面]]></title>
    <url>%2F2018%2F04%2F26%2Fcreate-react-app-%E9%85%8D%E7%BD%AE%E5%A4%9A%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[最近遇到一个需求，开发chrome插件的时候存在多个html页面，create-react-app 脚手架默认是单html开发的，所以需要重新配置一下wepack，实现多个页面输入和输出。 实例说明项目地址 完成后的目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566.├── LICENSE├── README.md├── build│ ├── asset-manifest.json│ ├── favicon.ico│ ├── houser.jpg│ ├── index.html│ ├── location.png│ ├── popup.html│ ├── service-worker.js│ └── static│ ├── css│ │ ├── index.773fa05a.css│ │ └── index.773fa05a.css.map│ └── js│ ├── index.98348617.js│ ├── index.98348617.js.map│ ├── popup.7ae02277.js│ └── popup.7ae02277.js.map├── build.zip├── config│ ├── env.js│ ├── jest│ │ ├── cssTransform.js│ │ └── fileTransform.js│ ├── paths.js│ ├── polyfills.js│ ├── webpack.config.dev.js│ ├── webpack.config.prod.js│ └── webpackDevServer.config.js├── package-lock.json├── package.json├── public│ ├── background│ │ ├── 139.jpg│ │ └── 444H.jpg│ ├── favicon.ico│ ├── houser.jpg│ ├── index.html│ └── location.png├── scripts│ ├── build.js│ ├── start.js│ └── test.js└── src ├── index │ ├── App.js │ ├── App.less │ ├── App.test.js │ ├── components │ ├── config.js │ ├── index.js │ ├── index.less │ ├── logo.svg │ ├── page │ ├── registerServiceWorker.js │ ├── service │ ├── stores │ └── utils └── popup ├── App.js ├── App.less ├── components ├── index.js └── registerServiceWorker.js 目录说明： 多个页面在分文件夹单独放置在src下,分别为index和popup，build之后都在一个文件里。为了缩短篇幅，删除一些无用目录。 流程暴露出create-react-app的配置文件1$ create-react-app eject 修改path找到config目录下的paths.js，添加需要的路径变量，后续引用 123456789101112131415module.exports = &#123; dotenv: resolveApp('.env'), appBuild: resolveApp('build'), appPublic: resolveApp('public'), appHtml: resolveApp('public/index.html'), appIndexJs: resolveApp('src/index/index.js'), //此处是默认页面入口js路径 appPopupJs: resolveApp('src/popup/index.js'), //自行添加的popup.html页面的入口js路径 appPackageJson: resolveApp('package.json'), appSrc: resolveApp('src'), yarnLockFile: resolveApp('yarn.lock'), testsSetup: resolveApp('src/setupTests.js'), appNodeModules: resolveApp('node_modules'), publicUrl: getPublicUrl(resolveApp('package.json')), servedPath: getServedPath(resolveApp('package.json')),&#125;; 修改webpack.config.dev.js修改webpack.config.dev.js entry增加入口文件 123456789101112entry: &#123; index: [ require.resolve('./polyfills'), require.resolve('react-dev-utils/webpackHotDevClient'), paths.appIndexJs, ], popup: [ require.resolve('./polyfills'), require.resolve('react-dev-utils/webpackHotDevClient'), paths.appPopupJs, // paths.js中配置的路径，也可以写成 paths.appSrc + '/popup/index.js', ] &#125;, 修改output输出文件名，避免冲突 12345678output: &#123; pathinfo: true, filename: 'static/js/[name].bundle.js', // 添加 [name] chunkFilename: 'static/js/[name].chunk.js', publicPath: publicPath, devtoolModuleFilenameTemplate: info =&gt; path.resolve(info.absoluteResourcePath).replace(/\\/g, '/'),&#125;, 增加并修改 HtmlWebpackPlugin 插件配置 12345678910111213141516plugins: [ // ... new HtmlWebpackPlugin(&#123; inject: true, chunks: ["index"], // 指定入口 js 文件 filename: 'index.html', //配置输入文件名 template: paths.appHtml, &#125;), new HtmlWebpackPlugin(&#123; inject: true, chunks: ["popup"], // 指定入口 js 文件 filename: 'popup.html', //配置输入文件名 template: paths.appHtml, &#125;), // ...], 修改webpack.config.prod.jswebpack.config.prod.js 修改方式跟 webpack.config.dev.js基本一样，只需要配置入口，出口和html插件,其他配置不要改变。 结语webpack的基本流程就是入口和出口，中间经过loader和插件进行处理，所以多页面的配置只需要针对入口和出口进行增加配置即可。例如build的时候也可以进行分文件导出，只需要调整一下文件生成路径就行。]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【分享】Modern Frontend Developer in 2018]]></title>
    <url>%2F2018%2F04%2F20%2F%E3%80%90%E5%88%86%E4%BA%AB%E3%80%91%E7%8E%B0%E4%BB%A3%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%8C%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%88%90%E4%B8%BA%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%2F</url>
    <content type="text"><![CDATA[全栈开发者 Kamran Ahmed 在github上制订了一份现代全栈开发的路线图，目前包含三部分：前端、后端、软件工程。目前该项目GitHub的stars达到了47000+，可见认可度非常高。本文是她对前端开发的整个学习过程的详细解释。 原文 译文 在此放上其前端路线图]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
        <tag>前端</tag>
        <tag>html</tag>
        <tag>vue</tag>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对table进行排序]]></title>
    <url>%2F2018%2F04%2F19%2F%E5%AF%B9table%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[百度2019前端实习生招聘的一道编程题：根据给定table字段进行升降排序，当时做得不太好，事后再实现一遍。 当时被HtmCollection卡住了一下，建议参考NodeList v.s. HTMLCollection 完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table id="jsList"&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;th&gt;sales&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;10.0&lt;/td&gt;&lt;td&gt;800&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;30.0&lt;/td&gt;&lt;td&gt;600&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;20.5&lt;/td&gt;&lt;td&gt;700&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;40.5&lt;/td&gt;&lt;td&gt;500&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;60.5&lt;/td&gt;&lt;td&gt;300&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;50.0&lt;/td&gt;&lt;td&gt;400&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;7&lt;/td&gt;&lt;td&gt;70.0&lt;/td&gt;&lt;td&gt;200&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;80.5&lt;/td&gt;&lt;td&gt;100&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;script&gt;var tableSort = function(selector, column, order) &#123; var table = document.querySelector(selector); var column_index = -1; //排序字段的索引 // 查找字段index var th_collection = table.querySelector('thead').querySelector('tr').getElementsByTagName('th'); Array.prototype.forEach.call(th_collection, function(el, index) &#123; if(el.innerHTML == column)&#123; column_index = index; &#125; &#125;) if(column_index == -1)&#123; alert('字段不存在'); return; &#125; // 获取dom collection var dom_lines = table.querySelector('tbody').children; // domlines 是HTML Collection对象，类数组，但不具有数组相关的方法，所以转换成数组 var lines = Array.prototype.slice.call(dom_lines, 0); lines.sort(function(a, b) &#123; var a_value = a.getElementsByTagName('td')[column_index].innerHTML; var b_value = b.getElementsByTagName('td')[column_index].innerHTML; return order == 'asc' ? a_value - b_value : b_value - a_value; &#125;) var new_table = document.createElement('tbody'); lines.forEach(function(el)&#123; new_table.appendChild(el); &#125;); table.replaceChild(new_table, table.querySelector('tbody'));&#125;tableSort('#jsList', 'id', 'desc'); &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html 中 p 标签的嵌套规则]]></title>
    <url>%2F2018%2F04%2F18%2Fp-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B5%8C%E5%A5%97%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[偶然遇到了 标签的嵌套问题，有必要mark一下。 p 标签内部不能嵌套 原始块元素，否则会通过自动闭合p标签，使块元素暴露出来 例如如下写法 123456&lt;p id="a"&gt; &lt;p id="b"&gt; &lt;div style="display: inline"&gt;123&lt;/div&gt; &lt;a href="" id="c"&gt;ccc&lt;/a&gt; &lt;/p&gt;&lt;/p&gt; 经过浏览器就会解析成 123456&lt;p id="a"&gt;&lt;/p&gt;&lt;p id="b"&gt;&lt;/p&gt;&lt;div style="display: inline"&gt;123&lt;/div&gt;&lt;a href="" id="c"&gt;ccc&lt;/a&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt; div 虽然加上了 display:inline 但是其本身是块级元素，所以在p标签中依然当做块元素对待]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端开发中用到的位置和尺寸]]></title>
    <url>%2F2018%2F04%2F13%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%B7%9D%E7%A6%BB%E5%92%8C%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[dom元素的位置和尺寸属性clientWidth/clientHeightclientHeight和clientWidth用于描述元素内尺寸，是指 元素内容+内边距 大小，不包括边框（IE下实际包括）、外边距、滚动条部分 clientLeft/clientTopclientTop和clientLeft返回内边距的边缘和边框的外边缘之间的水平和垂直距离，也就是左，上边框宽度 offsetWidth/offsetHeightoffsetHeight和offsetWidth用于描述元素外尺寸，是指 元素内容+内边距+边框，不包括外边距和滚动条部分 offsetLeft/offsetTopoffsetTop和offsetLeft表示该元素的左上角（边框外边缘）与已定位的父容器（offsetParent对象）左上角的距离 scrollWidth/scrollHeightscrollLeft/scrollTop参考链接 JavaScript获取DOM元素位置和尺寸大小JS获取浏览器窗口大小 获取屏幕，浏览器，网页高度宽度]]></content>
  </entry>
  <entry>
    <title><![CDATA[腾讯2018前端实习生招聘面试记录]]></title>
    <url>%2F2018%2F04%2F08%2F%E8%85%BE%E8%AE%AF2018%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[自己当时回答真是惨不忍睹，还好有录音，所以在此整理出来了所有问题。希望对后来着有所方向性指导。 自我介绍一下成绩在班级排名es6有接触吗？讲一下let和const？const还有什么需要注意？const a; 这样可以使用吗？let a = 1; let a = 2; 可以吗？箭头函数跟普通函数有什么区别？浏览器事件模型和时间委托？appyle与call的用途和区别？闭包是什么？原型链有什么特点？怎么把字符串转成数字？js如何实现继承？有那些方式？new的时候做了那些事情？ajax如何创建同步跟异步有什么区别如何解决跨域问题有看过jquery源码？jquery插件如何实现？描述一下react生命周期？如果不想更新某个组件，怎么做？react进行setState后会做那些工作？diff原理循环组件加上key的作用http的状态码有哪些？代表什么意思？babel的作用babel插件原理TCP的三次握手和四次挥手快速排序的原理？项目中有遇到什么难解决的问题，然后是怎么解决？7点15时针和分针点角度？介绍一下写的论文，做了什么事情？有用过redis吗？如果redis内存爆了，会怎么处理？有用node做过什么机试：1:页面内有一个正方形元素，实现对其拖拽和放下 2: 大数相加]]></content>
  </entry>
  <entry>
    <title><![CDATA[阿里蚂蚁金服2018前端实习生招聘面试记录]]></title>
    <url>%2F2018%2F04%2F08%2F%E9%98%BF%E9%87%8C%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D2018%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[自己当时回答真是惨不忍睹，还好有录音，所以在此整理出来了所有问题。希望对后来着有所方向性指导。 介绍一下闭包和他的作用？箭头函数更普通函数有什么区别？如何在浏览器里实现事件委托？解释一下cookie和seesion？如果我把别人的cookie拿过来，是不是就可以拿到他的登录信息？http是怎么区别header和body？http协议有哪些方式可以控制浏览器对资源的缓存在项目里有用过es的新语法吗？有什么作用？CMD和AMD有什么区别？react中列表组件key的作用react中setState一定会触发组件的更新吗？详细的说一下批量更新是怎么实现的？在一个方法里分别调用了包含setState操作的两个方法，这种情况会批量更新吗？jsx写的一个div，经过babel编译会变成什么样子？element，component，component实例有什么区别？redux如何处理异步？redux实现中间件的原理？js有哪些异步编程的模式？我看你自己写了几个项目，是完全自己从头写的还是用了脚手架活着模版？webpack打包的时候会做哪些优化？觉得自己比较精通或擅长的某个技术或者某个方面？最近有学什么新技术？mobx与redux有什么区别？mobx的观察者模式是怎么实现的？你会如何实现一个可观察的数组或者对象？特别了解的技术你有什么想问我的吗？问了一些蚂蚁的前端技术栈，他回答的是dva和antd 使用antd时候有遇到过什么问题？]]></content>
  </entry>
  <entry>
    <title><![CDATA[排序算法对比]]></title>
    <url>%2F2018%2F03%2F29%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[主要参考 十大经典排序算法总结（JavaScript描述） 原文更详细 名称 平均复杂度 最差复杂度 最优复杂度 空间开销 是否稳定 冒泡排序 $O( n^2 )$ $O( n^2 )$ $O( n^2 )$ $O(1) 是 选择排序 $O( n^2 )$ $O( n^2 )$ $O( n^2 )$ $O(1) 否 插入排序 $O( n^2 )$ $O( n^2 )$ $O( n^2 )$ $O(1) 是 希尔排序 $O( n\log(n) )$ $O( n^2 )$ $O( n\log_2n )$ $O(1) 否 快速排序 $O( n\log(n) )$ $O( n^2 )$ $O( n\log(n) )$ $O(1) 否 归并排序 $O( n\log(n) )$ $O( n\log(n) )$ $O( n\log(n) )$ $O(1) 是 堆排序 $O( n\log(n) )$ $O( n\log(n) )$ $O( n\log(n) )$ $O(1) 否 计数排序 $O( n + k )$ $O( n + k )$ $O( n + k )$ $O(1) 是 基数排序 $O( n * k )$ $O( n * k )$ $O( n * k )$ $O(1) 是 桶排序 $O( n + K )$ $O( n + K )$ $O( n^2 )$ $O(1) 是 堆排序中建堆过程的时间复杂度是 $O(n)$ 桶排序和基数排序均属于分配排序。分配排序的基本思想：排序过程无须比较关键字，而是通过用额外的空间来”分配”和”收集”来实现排序，它们的时间复杂度可达到线性阶：O(n)。简言之就是：用空间换时间，所以性能与基于比较的排序才有数量级的提高！ 参考 hexo中插入数学公式MathJax]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用命令]]></title>
    <url>%2F2018%2F03%2F27%2FLinux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[文件和目录cd 进入文件夹1$ cd ~ //进入用户目录 chmod 更改文件或目录权限 chmod [-R] xyz 1$ chmod 770 xyz ls 列出 –l 显示一个文件的属性以及文件所属的用户和组 -a 显示包含隐藏文件 1$ ls -a // 列出包含隐藏的文件 cp 复制 cp [-adfilprsu] 来源档(source) 目标档(destination) 1$ cp -r source destination // 递归持续复制，用於目录的复制行为；(常用) rm 删除 -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ mv 移动文件与目录，或修改名称 mv [options] source1 source2 source3 …. directorymv [-fiu] source destination 磁盘管理df 列出文件系统的整体磁盘使用量 -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统； -k ：以 KBytes 的容量显示各文件系统； -m ：以 MBytes 的容量显示各文件系统； -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示； -H ：以 M=1000K 取代 M=1024K 的进位方式； -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出； -i ：不用硬盘容量，而以 inode 的数量来显示 du 查看文件和目录磁盘使用的空间 du [-ahskm] 文件或目录名称 -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示；]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端技术栈速查（持续完善）]]></title>
    <url>%2F2018%2F03%2F26%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88%E9%80%9F%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[个人使用或收藏的前端开发工具，便于快速查找需要的工具，完善项目技术栈 react UI库antd element 浏览器实现页面生成pdf用html2canvas生成图片，再用jsPDF包装成pdf保存到本地html2canvas jsPDF]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
        <tag>html</tag>
        <tag>web</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL常用语句]]></title>
    <url>%2F2018%2F03%2F25%2FSQL%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[创建数据库 1CREATE DATABASE new_database; 显示数据库 1SHOW DATABASES ; 删除数据库 1DROP DATABASE example_1; 选择数据库 1USE example; 建表 CREATE TABLE 表名称(属性名 数据类型[约束条件]，属性名 数据类型[约束条件]); 1234567CREATE TABLE `fund_data` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `product_alias` varchar(64) NOT NULL DEFAULT '', `datetimes` varchar(64) NOT NULL DEFAULT '', `datas` varchar(64) NOT NULL DEFAULT '',PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=691865 DEFAULT CHARSET=utf8; 显示表 1show tables; 修改表名 1alter table 旧表名 rename to 新表名; 插入数据 insert [into] 表名 [(列名1, 列名2, 列名3, …)] values (值1, 值2, 值3, …); 1insert into students values(NULL, "王刚", "男", 20, "13811371377"); 1insert into students (name, sex, age) values("王刚", "男", 21); 更新数据 update 表名称 set 列名1=取值1，列名2=取值2 where … 删除数据 delete from 表名称 where… 1delete from students where id=2; 1delete from students where age&lt;20; 1delete from students;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node验证码生成工具]]></title>
    <url>%2F2018%2F03%2F25%2F%E3%80%90%E5%88%86%E4%BA%AB%E3%80%91node%E9%AA%8C%E8%AF%81%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[推荐一款node验证码生成工具 ccap 以下内容翻译自官方说明 不需要安装额外的库和软件，只需要用npm安装ccap就可以生成验证码。支持的node版本 0.12.x and 4.x.x 安装12345678910111213141516171819202122232425var captcha = ccap();var captcha = ccap(width, height, offset);var captcha = ccap(&#123; width:256,//set width,default is 256 height:60,//set height,default is 60 offset:40,//set text spacing,default is 40 quality:100,//set pic quality,default is 50 fontsize:57,//set font size,default is 57 generate:function()&#123;//Custom the function to generate captcha text //generate captcha text here return text;//return the captcha text &#125;&#125;); 简单示例123456789101112131415161718192021var http = require('http');var ccap = require('ccap')();//Instantiated ccap class http.createServer(function (request, response) &#123; if(request.url == '/favicon.ico')return response.end('');//Intercept request favicon.ico var ary = ccap.get(); var txt = ary[0]; var buf = ary[1]; response.end(buf); console.log(txt);&#125;).listen(8124);console.log('Server running at http://127.0.0.1:8124/'); API1234567var captcha = ccap();var ary = captcha.get();//ary[0] is captcha's text,ary[1] is captcha picture buffer.var text = ary[0];var buffer = ary[1]; 停止或开启缓存定时器1234567891011var ccap = require('ccap')();ccap.timerIsRunning(); //now timer is running, return 1ccap.clearTimeout(); //stop all create capature image, so will use the same the 20(default is 20) capature imagesccap.timerIsRunning();//now timer is stoped, return 0captcha8.setTimeout();//now timer is start againccap.timerIsRunning();//now timer is stoped, return 1]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>node</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode中开启emmet对jsx的支持]]></title>
    <url>%2F2018%2F03%2F03%2Fvscode%E4%B8%AD%E5%BC%80%E5%90%AFemmet%E5%AF%B9jsx%E7%9A%84%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[在用户配置文件里添加如下配置, class会自动转化为className 1234"emmet.syntaxProfiles": &#123; "javascript": "jsx" &#125;,"emmet.triggerExpansionOnTab": true,]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-mobx-less-router架构起手]]></title>
    <url>%2F2018%2F03%2F02%2Freact-mobx-less-router%E6%9E%B6%E6%9E%84%E8%B5%B7%E6%89%8B%2F</url>
    <content type="text"><![CDATA[使用create-react-app创建项目创建项目create-react-app project 抛出配置文件npm run eject mobx安装mobxnpm install mobx mobx-react –save mobx中文文档 启用装饰器语法 在MobX 中使用 ES.next 装饰器是可选的。本章节将解释如何(避免)使用它们。 使用装饰器的优势: 样板文件最小化，声明式代码。易于使用和阅读。大多数 MobX 用户都在使用。 Babel中启用装饰器安装依赖npm i –save-dev babel-plugin-transform-decorators-legacy 编辑package.json，添加plugins，修改后如下 12345678"babel": &#123; "presets": [ "react-app" ], "plugins": [ "transform-decorators-legacy" ] &#125;, 在index.js文件中注入store1234567891011121314151617181920import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import registerServiceWorker from './registerServiceWorker';import &#123; HashRouter &#125; from 'react-router-dom';import &#123; Provider &#125; from 'mobx-react';import ResumeStore from './store/ResumeStore';let stores = &#123; ResumeStore,&#125;;ReactDOM.render(( &lt;Provider &#123;...stores&#125;&gt; &lt;HashRouter&gt; &lt;App /&gt; &lt;/HashRouter&gt; &lt;/Provider&gt;),document.getElementById('root'));registerServiceWorker(); 配置react-router安装react-routernpm install –save react-router App.js文件中配置路由123456789101112131415161718192021import React, &#123; Component &#125; from 'react';import './App.less';import &#123; Route, Switch,&#125; from 'react-router-dom'import Index from './page/Index';class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Switch&gt; &lt;Route path="/" component=&#123;Index&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; ); &#125;&#125;export default App; 配置 less安装依赖npm install less-loader less –save-dev 修改配置文件修改 config文件夹下的 webpack.config.dev.js 和 webpack.config-prod.js test: /.css$/ 改为 /.(css|less)$/ test: /.css$/ 的 use 数组配置增加 less-loader 修改后 1234567891011121314151617181920212223242526272829303132333435&#123; test: /\.(css|less)$/, use: [ require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('less-loader') // compiles Less to CSS &#125; ],&#125;]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【翻译】没有常春藤学校学位的我是如何获得微软、亚马逊、推特的offer]]></title>
    <url>%2F2018%2F03%2F02%2F%E7%BF%BB%E8%AF%91-%E6%B2%A1%E6%9C%89%E5%B8%B8%E6%98%A5%E8%97%A4%E5%AD%A6%E6%A0%A1%E5%AD%A6%E4%BD%8D%E7%9A%84%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E5%BE%AE%E8%BD%AF%E3%80%81%E4%BA%9A%E9%A9%AC%E9%80%8A%E3%80%81%E6%8E%A8%E7%89%B9%E7%9A%84offer%2F</url>
    <content type="text"><![CDATA[原文：How I landed offers from Microsoft, Amazon, and Twitter without an Ivy League degree]]></content>
      <tags>
        <tag>job</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript有用的代码片段]]></title>
    <url>%2F2018%2F02%2F20%2FJavaScript%E6%9C%89%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%92%8Ctrick%2F</url>
    <content type="text"><![CDATA[参考 JavaScript有用的代码片段和trick 浮点数取整12345const x = 123.4545;x &gt;&gt; 0; // 123~~x; // 123x | 0; // 123Math.floor(x); // 123 注意：前三种方法只适用于32个位整数，对于负数的处理上和Math.floor是不同的。123&gt; Math.floor(-12.53); // -13&gt; -12.53 | 0; // -12&gt; 生成6位数字验证码1234567891011// 方法一('000000' + Math.floor(Math.random() * 999999)).slice(-6);// 方法二Math.random().toString().slice(-6);// 方法三Math.random().toFixed(6).slice(-6);// 方法四'' + Math.floor(Math.random() * 999999); url查询参数转json格式12345678910111213141516171819// ES6const query = (search = '') =&gt; ((querystring = '') =&gt; (q =&gt; (querystring.split('&amp;').forEach(item =&gt; (kv =&gt; kv[0] &amp;&amp; (q[kv[0]] = kv[1]))(item.split('='))), q))(&#123;&#125;))(search.split('?')[1]);// 对应ES5实现var query = function(search) &#123; if (search === void 0) &#123; search = ''; &#125; return (function(querystring) &#123; if (querystring === void 0) &#123; querystring = ''; &#125; return (function(q) &#123; return (querystring.split('&amp;').forEach(function(item) &#123; return (function(kv) &#123; return kv[0] &amp;&amp; (q[kv[0]] = kv[1]); &#125;)(item.split('=')); &#125;), q); &#125;)(&#123;&#125;); &#125;)(search.split('?')[1]);&#125;;query('?key1=value1&amp;key2=value2'); // es6.html:14 &#123;key1: "value1", key2: "value2"&#125; 获取URL参数12345678function getQueryString(key)&#123; var reg = new RegExp("(^|&amp;)"+ key +"=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if(r!=null)&#123; return unescape(r[2]); &#125; return null;&#125; n维数组展开成一维数组1234567891011121314151617181920212223242526var foo = [1, [2, 3], ['4', 5, ['6',7,[8]]], [9], 10];// 方法一// 限制：数组项不能出现`,`，同时数组项全部变成了字符数字foo.toString().split(','); // ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]// 方法二// 转换后数组项全部变成数字了eval('[' + foo + ']'); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]// 方法三，使用ES6展开操作符// 写法太过麻烦，太过死板[1, ...[2, 3], ...['4', 5, ...['6',7,...[8]]], ...[9], 10]; // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]// 方法四JSON.parse(`[$&#123;JSON.stringify(foo).replace(/\[|]/g, '')&#125;]`); // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]// 方法五const flatten = (ary) =&gt; ary.reduce((a, b) =&gt; a.concat(Array.isArray(b) ? flatten(b) : b), []);flatten(foo); // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10]// 方法六function flatten(a) &#123; return Array.isArray(a) ? [].concat(...a.map(flatten)) : a;&#125;flatten(foo); // [1, 2, 3, "4", 5, "6", 7, 8, 9, 10] 日期格式化12345678910111213141516171819202122232425262728293031323334353637383940// 方法一function format1(x, y) &#123; var z = &#123; y: x.getFullYear(), M: x.getMonth() + 1, d: x.getDate(), h: x.getHours(), m: x.getMinutes(), s: x.getSeconds() &#125;; return y.replace(/(y+|M+|d+|h+|m+|s+)/g, function(v) &#123; return ((v.length &gt; 1 ? "0" : "") + eval('z.' + v.slice(-1))).slice(-(v.length &gt; 2 ? v.length : 2)) &#125;);&#125;format1(new Date(), 'yy-M-d h:m:s'); // 17-10-14 22:14:41// 方法二Date.prototype.format = function (fmt) &#123; var o = &#123; "M+": this.getMonth() + 1, //月份 "d+": this.getDate(), //日 "h+": this.getHours(), //小时 "m+": this.getMinutes(), //分 "s+": this.getSeconds(), //秒 "q+": Math.floor((this.getMonth() + 3) / 3), //季度 "S": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); &#125; for (var k in o)&#123; if (new RegExp("(" + k + ")").test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); &#125; &#125; return fmt;&#125;new Date().format('yy-M-d h:m:s'); // 17-10-14 22:18:17 匿名函数自执行写法1234567891011121314151617181920( function() &#123;&#125;() );( function() &#123;&#125; )();[ function() &#123;&#125;() ];~ function() &#123;&#125;();! function() &#123;&#125;();+ function() &#123;&#125;();- function() &#123;&#125;();delete function() &#123;&#125;();typeof function() &#123;&#125;();void function() &#123;&#125;();new function() &#123;&#125;();new function() &#123;&#125;;var f = function() &#123;&#125;();1, function() &#123;&#125;();1 ^ function() &#123;&#125;();1 &gt; function() &#123;&#125;(); 数字字符转数字12var a = '1';+a; // 1 最短的代码实现数组去重1[...new Set([1, "1", 2, 1, 1, 3])]; // [1, "1", 2, 3]]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向学生的微信开发建议]]></title>
    <url>%2F2018%2F02%2F09%2F%E9%9D%A2%E5%90%91%E5%AD%A6%E7%94%9F%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[微信开发学习建议了解微信开发微信功能的实现主要依托期微信公众平台，即订阅号、服务号、企业号、小程序。功能对比。功能说明。 开发文档是主要参考文档，有所有能用的功能和实现说明 认证与未认证的订阅号/服务号接口权限区别很大。 学习过程中可以开通测试账号，无需认证就具备所有高级接口权限 开发建议准备 购买学生版服务器 腾讯云 阿里云 相对偏贵，性能好 装linux系统，推荐 ubuntu 推荐服务器软件管理软件 amh 注册个人域名并备案 通过Github管理个人项目 使用Google搜索（翻墙方案很多，建议自己找两三个同学合伙搭建翻墙服务器，推荐VPS服务商 vultr $2.5/月, 工具 shadowsocks） 学习流程 注册微信公众平台测试号 搭建服务器运行环境，解析域名 （ 必须，微信开发有域名安全机制，并能正常访问 ） 部署基础项目 实现微信登录功能 实现JS-SDK功能 实现微信支付功能（ 需要以公司名义开通，流程教复杂 ） 调试技巧 微信web开发者工具 在chrome的基础上输出更多调试信息 chrome 学会用谷歌浏览器调试 真机调试 页面在微信上对显示效果跟电脑上不完全一样，存在兼容性问题，这个时候，如果在本地开发，可以把本地启动对服务器暴露到局域网，用手机通过ip访问 开发模式：微信网页开发 （最常用）通过微信打开的页面能使用微信app提供的功能，相当于在常见页面里拓展一些功能，可以把微信理解成具有特殊功能的浏览器 常用的有 微信登录：订阅号/服务号都支持 微信支付：服务号支持 JS-SDK：微信打开的页面通过js调取微信app的拥有的功能,常用的有 分享页面 上传下载图片 扫一扫 微信交互开发在公众号界面通过聊天的形式进行交互 接受消息 回复消息 通知消息 APP开发在非微信app中调起微信登录和微信支付 开发流程 确定需求，注册合适的公众号 注册域名，服务器 配置微信公众号 （ 根据需要使用的微信功能进行配置，开发文档有说明 ） 选取合适的语言和框架 搭建开发环境 服务器软件 （ Apache / Nginx ） 语言运行环境 版本管理系统（ 方便代码管理和多人开发 Git / Svn ） 开发 测试 ( 测试覆盖面要全，极端值也需要测试 ) 上线 主要微信功能说明]]></content>
      <tags>
        <tag>web</tag>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云视频上传在React中的实现]]></title>
    <url>%2F2017%2F12%2F20%2F%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91%E4%B8%8A%E4%BC%A0%E5%9C%A8React%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在原项目基础上进行了删减，用了antd UI库，能够显示当前上传进度，采用阿里云点播凭证方式上传，不是OSS的上传模式，可以根据官方demo进行调整 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160import React, &#123;Component&#125; from 'react';import &#123;Button, Col, Form, Icon, Input, message, Modal, Row, Select, Switch, Upload&#125; from 'antd';import &#123; loadServiceCourseDataSet, loadUploadVideoAuth, reloadUploadVideoAuth, updateServiceCourseItem&#125; from '../../../service/course';import LazyLoad from 'react-lazy-load';const FormItem = Form.Item;// 创建 上传实例 变量，多次尝试后放在这里才靠谱var uploader;class Update extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; fileList: [], aliVideoAuthDto: &#123; requestId: '', uploadAddress: '', uploadAuth: '', videoId: '' &#125;, upload_progress: '' &#125; &#125; componentDidMount() &#123; let _this = this; uploader = new VODUpload(&#123; // 文件上传失败 'onUploadFailed': function (uploadInfo, code, message) &#123; message.fail('上传失败，请稍后再试'); //console.log("onUploadFailed: file:" + uploadInfo.file.name + ",code:" + code + ", message:" + message); &#125;, // 文件上传完成 'onUploadSucceed': function (uploadInfo) &#123; _this.setState(&#123; uploading: false&#125;) message.success('上传成功'); //console.log("onUploadSucceed: " + uploadInfo.file.name + ", endpoint:" + uploadInfo.endpoint + ", bucket:" + uploadInfo.bucket + ", object:" + uploadInfo.object); &#125;, // 文件上传进度 'onUploadProgress': function (uploadInfo, totalSize, uploadedSize) &#123; //console.log("onUploadProgress:file:" + uploadInfo.file.name + ", fileSize:" + totalSize + ", percent:" + Math.ceil(uploadedSize * 100 / totalSize) + "%"); _this.setState(&#123; upload_progress: Math.ceil(uploadedSize * 100 / totalSize) + "%"&#125;) &#125;, // STS临时账号会过期，过期时触发函数 'onUploadTokenExpired': function () &#123; message.success('上传凭证过期，请重试'); //console.log("onUploadTokenExpired"); &#125;, // 开始上传 'onUploadstarted': function (uploadInfo) &#123; _this.setState(&#123; uploading: true &#125;); uploader.setUploadAuthAndAddress(uploadInfo, _this.state.aliVideoAuthDto.uploadAuth, _this.state.aliVideoAuthDto.uploadAddress); &#125; &#125;); uploader.init(); &#125; normFile = (e) =&gt; &#123; console.log('Upload event:', e); if (Array.isArray(e)) &#123; return e.file; &#125; return e &amp;&amp; e.fileList; &#125; doUpload = () =&gt; &#123; console.log('start'); uploader.startUpload(); &#125;; render() &#123; const &#123;getFieldDecorator&#125; = this.props.form; const formItemLayout = &#123; labelCol: &#123; xs: &#123;span: 24&#125;, sm: &#123;span: 4&#125;, &#125;, wrapperCol: &#123; xs: &#123;span: 24&#125;, sm: &#123;span: 18&#125;, &#125;, &#125;; const uploadProps = &#123; action: '//jsonplaceholder.typicode.com/posts/', onRemove: (file) =&gt; &#123; this.setState((&#123;fileList&#125;) =&gt; &#123; const index = fileList.indexOf(file); const newFileList = fileList.slice(); newFileList.splice(index, 1); return &#123; fileList: newFileList, &#125;; &#125;); &#125;, beforeUpload: (file) =&gt; &#123; let userData = '&#123;"Vod":&#123;"UserData":"&#123;"IsShowWaterMark":"false","Priority":"7"&#125;"&#125;&#125;'; console.log(file); this.setState(&#123;videoSize: file.size&#125;) uploader.addFile(file, null, null, null, userData); // 获取上传凭证 loadUploadVideoAuth(&#123; courseItemId: this.props.data.id, videoName: file.name, videoTitle: file.name, videoTags: file.name, videoDesc: file.name, &#125;).then(data =&gt; &#123; this.setState(&#123;aliVideoAuthDto: data.data.aliVideoAuthDto&#125;); &#125;); this.setState((&#123;fileList&#125;) =&gt; (&#123; fileList: [...fileList, file], &#125;)); return false; &#125;, fileList: this.state.fileList, &#125;; return ( &lt;Modal title="更新" visible=&#123;this.props.show&#125; onCancel=&#123;this.props.onCancel&#125; footer=&#123;null&#125; width=&#123;'80%'&#125;&gt; &lt;Row type='flex' style=&#123;&#123;marginBottom: '5px'&#125;&#125;&gt; &lt;Col span=&#123;24&#125;&gt; &lt;FormItem &#123;...formItemLayout&#125; label="课程视频"&gt; &lt;Upload &#123;...uploadProps&#125;&gt; &lt;Button&gt; &lt;Icon type="upload"/&gt; 选择文件 &lt;/Button&gt; &lt;/Upload&gt; &lt;Button type="primary" onClick=&#123;this.doUpload&#125; disabled=&#123;this.state.fileList.length === 0&#125; loading=&#123;this.state.uploading&#125;&gt; &#123;this.state.uploading ? this.state.upload_progress : '开始上传'&#125; &lt;/Button&gt; &lt;/FormItem&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;FormItem wrapperCol=&#123;&#123;span: 12, offset: 4&#125;&#125;&gt; &lt;Button type="primary" onClick=&#123;this.handleSubmit&#125;&gt;提交更新&lt;/Button&gt; &lt;/FormItem&gt; &lt;/Modal&gt; ) &#125;&#125;export default Form.create()(Update);]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云视频点播在React中的实现]]></title>
    <url>%2F2017%2F12%2F20%2F%E9%98%BF%E9%87%8C%E4%BA%91%E8%A7%86%E9%A2%91%E7%82%B9%E6%92%AD%E5%9C%A8React%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在原项目组件上进行了删减，保留核心代码，不一定能直接运行，需要根据情况调整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import React, &#123; Component &#125; from 'react';import &#123; hashHistory &#125; from 'react-router';class CourseDetail extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; this.player = null; // 创建播放器实例变量 &#125; componentDidMount() &#123; // 初始化播放器, this.player = new Aliplayer(&#123; id: 'Ali_Player', // 容器id vid: '', width: "100%", // 播放器宽度 playauth: '', cover: `$&#123;IMG_DOMAIN&#125;$&#123;data.data.serviceCourseDto.serviceCourse.coverUrl&#125;`, autoplay: false, rePlay: false, skinLayout:[&#123;"name":"H5Loading","align":"cc"&#125;, &#123;"name":"errorDisplay","align":"tlabs","x":0,"y":0&#125;, &#123;"name":"infoDisplay","align":"cc"&#125;, &#123;"name":"controlBar","align":"blabs","x":0,"y":0,"children":[&#123;"name":"progress","align":"tlabs","x":0,"y":0&#125;, &#123;"name":"timeDisplay","align":"tl","x":10,"y":24&#125;]&#125;] &#125;); this.player.on('play',()=&gt;&#123; if(this.state.cur_courseitem.courseItemId)&#123; this.player.play(); &#125; else &#123; this.player.pause(); Toast.info('请选择章节'); &#125; &#125;) &#125; handlePlay = (courseItemId) =&gt; &#123; // 播放事件，此时获取播放凭证，也可以在挂载的时候获取播放凭证 loadVideoPalyAuth(&#123;courseItemId&#125;).then(data =&gt; &#123; this.setState(&#123; cur_courseitem: &#123; ...this.state.cur_courseitem, videoId: data.data.aliVideoPlayAuthDto.videoId, playauth: data.data.aliVideoPlayAuthDto.playAuth, courseItemId: courseItemId &#125; &#125;,()=&gt;&#123; if (this.player)&#123; this.player.dispose(); &#125; this.player = new Aliplayer(&#123; id: 'Ali_Player', // 容器id vid: data.data.aliVideoPlayAuthDto.videoId, width: "100%", // 播放器宽度 playauth: data.data.aliVideoPlayAuthDto.playAuth, autoplay: false, rePlay: false, &#125;); &#125;); &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handlePlay&#125;&gt;播放&lt;/button&gt; &lt;div className="prism-player" id='Ali_Player' /&gt; &lt;/div&gt; ); &#125;&#125;export default CourseDetail;]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人总结的react脚手架]]></title>
    <url>%2F2017%2F09%2F07%2F%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E7%9A%84react%E8%84%9A%E6%89%8B%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[react-clireact应用的起步工程和总结 Github传送门 特点采用时下流行的技术栈，视图：react，状态管理：redux，路由：react-router 作为基础，配合webpack等开发工具而搭建的项目架构，适用于中小型项目，也可以在此基础上进行调整适合更多类型的项目。 同时还会提供react开发相关的资料、疑问、解决方案等，希望对开发者有所帮助，也对自己的技术有所提升。欢迎大家提供建议 技术栈 react redux react-router mock pace whatwg-fetch 项目构建目录结构123456789101112131415161718192021222324252627282930313233343536.├── README.md├── build #构建生成目录│ ├── bundle │ └── index.html├── package-lock.json├── package.json├── src #源代码文件│ ├── action.js #action创建函数文件│ ├── components #组件目录 *1│ │ ├── layout│ │ └── notify│ ├── http.js #所有fetch请求 *2│ ├── index.html #webpack生成html的模板 *3│ ├── index.js #入口文件│ ├── reducer.js #reducer *4│ ├── router.js #路由定义│ ├── routes #路由对应的page目录│ │ ├── App.js #入口文件 *5│ │ ├── index #一个页面对应一个文件夹 *6│ │ │ ├── Index.js│ │ │ └── index.scss│ │ └── login│ │ ├── Login.js│ │ └── login.scss│ ├── static #静态文件夹│ │ └── logo.jpg│ ├── store.js #store创建文件 *7│ └── utils #工具集│ ├── config.js #项目配置│ ├── mock.js #本地mock数据│ ├── pace.css #首屏加载动画css│ ├── pace.js #首屏加载动画js│ └── theme.scss #主题sass变量├── webpack.config.js #webpack开发配置文件└── webpack.production.config.js #webpack构建配置文件 目录结构说明 components 每一个组件对应一个文件夹，包含该组件js以及css，更小的组件也放在该文件夹下 将所有的请求独立出来放在一个文件里，每个fetch请求封装成一个回调函数并export 采用自定义html模板进行打包便于引用cdn等文件，或者其他自定义操作 项目复杂的时候可以创建reducer文件夹，进一步拆分 每个页面都是该组件的字组件，便于引入例如通知等全局组件 每个页面对应一个文件夹，因为一个页面包含的组件较多，利于拆分 独立出来store是便于在非组件的文件中操作reducer的store 开发说明克隆项目: 1git clone https://github.com/Houserqu/react-cli.git 进入项目目录安装依赖: 1npm i 开发: 1npm run dev 构建: 1npm run build]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>webpack</tag>
        <tag>react-router</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曲折回学路]]></title>
    <url>%2F2017%2F09%2F05%2F%E6%9B%B2%E6%8A%98%E5%9B%9E%E5%AD%A6%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[时隔五个月，终于再次回到学校，从去年12月份检查出病到现在，居然已经有十余月，真的不知道是如何走到现在的。这次病魔缠身，对我身体和精神带来了巨大打击，对家人也是带来了沉重的负担，感触颇深，希望对生命有重新的认识吧。不彻底痛苦一次，就不会知道生活恶习所引发的蝴蝶效应。 虽然已经回到学校，但似乎还没有那么顺利上课，治疗时间还没有达到规定，只好按规定办事了。 左手静脉血管上扎的疤痕依旧清晰可见，一天大把的药还需要服用，革命尚未成功！只能告诫自己好好爱惜身体吧。 这次回校真的激动万分，见到了等待已久的她，见到了高谈阔论的室友。生活很美好！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[fetch post formData]]></title>
    <url>%2F2017%2F08%2F18%2Ffetch-post-formData%2F</url>
    <content type="text"><![CDATA[当使用fetch用表单的方式post json类型的数据时候，需要注意几个问题 header设置header 的 ‘Content-Type’,’application/x-www-form-urlencoded;charset=utf-8’ 序列化json尝试过多种方式，需要处理成 ‘username=admin&amp;password=password’这种方式才能被正确的识别成 formData格式，可以在浏览器查看具体的请求体采用类似 new FormData() 方式会被处理成——WebKitFormBoundary 具体示例 1234567891011121314151617//序列化jsonconst formBody = Object.keys(paramsArray).map(key=&gt;encodeURIComponent(key)+'='+encodeURIComponent(paramsArray[key])) .join('&amp;');var headers = new Headers();headers.set('Content-Type','application/x-www-form-urlencoded;charset=utf-8');fetch('api/auth/login',&#123; method:'post', mode:'cors', credentials: "include", headers, body: formBody&#125;).then((response)=&gt;&#123; return response.json(); &#125;).then((responseData)=&gt;&#123; console.log(responseData);&#125;); 参考：四种常见的 POST 提交数据方式how to post a x-www-form-urlencoded request from react-nativeHow to make a post request with JSON data in application/x-www-form-urlencoded]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX/Fetch 在跨域情况下发送cookie并保持 sessionid一致]]></title>
    <url>%2F2017%2F08%2F18%2FAJAX-Fetch%E5%9C%A8%E8%B7%A8%E5%9F%9F%E6%83%85%E5%86%B5%E5%8F%91%E9%80%81cookie%E5%B9%B6%E4%BF%9D%E6%8C%81sessionid%E4%B8%80%E8%87%B4%2F</url>
    <content type="text"><![CDATA[Ajaxajax在跨域发送请求的时候需要添加 xhrFields 12345678910111213$.ajax(&#123; url:'example.com', method:'post', datatype:'json', xhrFields: &#123; withCredentials: true &#125;, crossDomain: true, data:param, success:function(data)&#123; console.log(data); &#125; &#125;) Fetchfetch在跨域发送请求的时候需要添加 credentials: “include” 12345678910fetch('http://example.com',&#123; method:'post', mode:'cors', credentials: "include", body: param&#125;).then((response)=&gt;&#123; return response.json(); &#125;).then((responseData)=&gt;&#123; console.log(responseData);&#125;); 参考：Ajax跨域请求，同时保证session一致Fetch API with Cookie]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ajax</tag>
        <tag>fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换新的Blog系统]]></title>
    <url>%2F2017%2F08%2F06%2F%E6%9B%B4%E6%8D%A2%E6%96%B0%E7%9A%84Blog%2F</url>
    <content type="text"><![CDATA[经过长时间的调研，钻研，新的blog系统终于上线了 从wordpress，到个人用react+laravel开发，到现在的github pages 觉得目前的模式还是挺不错的，github，nodejs，markdown都是我非常喜欢的技术，这三者的结合希望能给我带来愉快的码字体验 当然最重要的还是多敲多写 好记性不如烂指头]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node</tag>
      </tags>
  </entry>
</search>
